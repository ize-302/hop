#!/bin/bash

SCRIPT_PATH="$(realpath "$0")"

# Config
CONFIG_DIR="$HOME/.config/hop"
BOOKMARKS_FILE="$CONFIG_DIR/sessions.toml"
ACCESS_FILE="$CONFIG_DIR/last_accessed.toml"
CACHE_DIR="$CONFIG_DIR/cache"
CACHE_TTL=5  # Cache TTL in seconds
DEBUG=0

# Colors
GREEN='\033[1;32m'  # Bold green for attached
GRAY='\033[37m'     # Light gray for non-attached
YELLOW='\033[33m'   # Yellow for bookmark star
DIM='\033[90m'      # Dim for (new) indicator
RESET='\033[0m'

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"

# Timestamp utilities
get_current_timestamp() {
	date -u +%Y-%m-%dT%H:%M:%SZ
}

parse_timestamp_to_epoch() {
	date -d "$1" +%s 2>/dev/null || echo "0"
}

# Get data directory (works for both development and installed versions)
get_data_dir() {
	local script_dir="$(dirname "$(realpath "$0")")"
	# First try relative to script (development)
	if [ -d "${script_dir}/data" ]; then
		echo "${script_dir}/data"
	# Then try installed location (relative to bin directory)
	elif [ -d "${script_dir}/../share/hop" ]; then
		echo "${script_dir}/../share/hop"
	# Then try absolute installed location
	elif [ -d "/usr/local/share/hop" ]; then
		echo "/usr/local/share/hop"
	else
		echo "data"  # Fallback for compatibility
	fi
}

# Cache functions for performance optimization
ensure_cache_dir() {
	mkdir -p "$CACHE_DIR" 2>/dev/null
}

is_cache_valid() {
	local cache_file="$1"
	local max_age="$2"
	[ -f "$cache_file" ] && [ $(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || date +%s))) -lt $max_age ]
}

get_cached_content() {
	local cache_file="$1"
	local ttl="${2:-$CACHE_TTL}"

	if is_cache_valid "$cache_file" "$ttl"; then
		cat "$cache_file" 2>/dev/null
	else
		# Content will be provided via stdin
		cat > "$cache_file"
		cat "$cache_file"
	fi
}

ensure_cache_dir

# Parse saved sessions from TOML file (with caching and lazy loading)
# Outputs: name<TAB>path<TAB>startup_command (one per line)
parse_saved_sessions() {
	# Lazy loading: only parse if sessions.toml exists and has content
	if [ ! -f "$BOOKMARKS_FILE" ] || [ ! -s "$BOOKMARKS_FILE" ]; then
		return
	fi

	local cache_file="$CACHE_DIR/saved_sessions"

	if is_cache_valid "$cache_file" "$CACHE_TTL"; then
		cat "$cache_file" 2>/dev/null
	else
		local content
		content=$(python3 << 'EOF'
import tomllib
import os

config_path = os.path.expanduser("~/.config/hop/sessions.toml")
if os.path.exists(config_path):
    with open(config_path, "rb") as f:
        data = tomllib.load(f)
    for session in data.get("session", []):
        name = session.get("name", "")
        path = session.get("path", "")
        cmd = session.get("startup_command", "")
        print(f"{name}\t{path}\t{cmd}")
EOF
)
		echo "$content" > "$cache_file" 2>/dev/null || true
		echo "$content"
	fi
}

# Check if a session name is in the saved sessions
is_saved_session() {
	local session_name="$1"
	parse_saved_sessions | cut -f1 | grep -qxF "$session_name"
}

# Get the config (path and startup_command) for a saved session
# Outputs: path<TAB>startup_command
get_saved_session_config() {
	local session_name="$1"
	parse_saved_sessions | while IFS=$'\t' read -r name path cmd; do
		if [ "$name" = "$session_name" ]; then
			echo "$path"$'\t'"$cmd"
			break
		fi
	done
}

# Check if a tmux session exists
session_exists() {
	tmux has-session -t "$1" 2>/dev/null
}

format_time_ago() {
	local created_ts=$1
	local now_ts=$(date +%s)
	local diff=$((now_ts - created_ts))
	local day_secs=86400

	if [ $diff -ge $day_secs ]; then
		# Past 24hrs - show full date-time
		date -d "@$created_ts" "+%Y-%m-%d %H:%M:%S"
	else
		# Within 24hrs - show time ago
		if [ $diff -lt 60 ]; then
			echo "${diff}s ago"
		elif [ $diff -lt 3600 ]; then
			echo "$((diff / 60))m ago"
		else
			echo "$((diff / 3600))h $((diff % 3600 / 60))m ago"
		fi
	fi
}

get_formatted_sessions() {
	local all_sessions=()
	local attached_session=""
	local current_session=""

	# Get current session name (session attached to current client)
	if [ -n "$TMUX" ]; then
		current_session=$(tmux display-message -p '#S' 2>/dev/null)
	fi

	# Build associative array of existing tmux sessions (with caching)
	declare -A tmux_sessions
	declare -A tmux_timestamps
	declare -A tmux_attached

	local tmux_cache_file="$CACHE_DIR/tmux_ls"
	local tmux_output

	if is_cache_valid "$tmux_cache_file" 3; then
		tmux_output=$(cat "$tmux_cache_file" 2>/dev/null)
	else
		tmux_output=$(tmux ls 2>/dev/null)
		echo "$tmux_output" > "$tmux_cache_file" 2>/dev/null || true
	fi

	while IFS= read -r line; do
		[ -z "$line" ] && continue
		session_name=$(echo "$line" | cut -d':' -f1)
		date_str=$(echo "$line" | grep -oP 'created \K[^)]+')
		created_ts=$(date -d "$date_str" +%s 2>/dev/null)

		tmux_sessions["$session_name"]=1
		tmux_timestamps["$session_name"]=$created_ts

		if echo "$line" | grep -q "(attached)"; then
			tmux_attached["$session_name"]=1
		fi
	done <<< "$tmux_output"
	
	# Process saved sessions first (in order from TOML)
	declare -A saved_session_names
	while IFS=$'\t' read -r name path cmd; do
		[ -z "$name" ] && continue
		saved_session_names["$name"]=1
		
		if [ -n "${tmux_sessions[$name]}" ]; then
			# Session exists
			local formatted_date=$(format_time_ago "${tmux_timestamps[$name]}")
			local color=$GRAY
			if [ -n "${tmux_attached[$name]}" ]; then
				color=$GREEN
			fi

			local star=""
			if [ "$name" = "$current_session" ]; then
				star=" *"
			fi

			saved_sessions+=("${YELLOW}★ ${RESET}${color}${name} · ${formatted_date}${star}${RESET}")
		else
			# Session doesn't exist - show as (new)
			saved_sessions+=("${YELLOW}★ ${RESET}${GRAY}${name} ${DIM}· (saved)${RESET}")
		fi
	done <<< "$(parse_saved_sessions)"
	
	# Process regular tmux sessions (not in saved list)
	while IFS= read -r line; do
		[ -z "$line" ] && continue
		session_name=$(echo "$line" | cut -d':' -f1)

		# Skip if this is a saved session
		[ -n "${saved_session_names[$session_name]}" ] && continue

		date_str=$(echo "$line" | grep -oP 'created \K[^)]+')
		created_ts=$(date -d "$date_str" +%s 2>/dev/null)
		
		if [ -n "$created_ts" ]; then
			formatted_date=$(format_time_ago "$created_ts")
			local color=$GRAY
			if [ -n "${tmux_attached[$session_name]}" ]; then
				color=$GREEN
			fi

			local star=""
			if [ "$session_name" = "$current_session" ]; then
				star=" *"
			fi

			regular_sessions[$ri]="${color}${session_name} · ${formatted_date}${star}${RESET}"
			regular_timestamps[$ri]=$created_ts
			((ri++))
		fi
	done <<< "$tmux_output"
	
	# Find the attached session and output it first
	local attached_session_name=""
	local attached_display=""

	# Priority: current client's session
	attached_session_name="$current_session"

	# Fallback: if no current session, use first attached session
	if [ -z "$attached_session_name" ]; then
		for session_name in "${!tmux_attached[@]}"; do
			if [ -n "${tmux_attached[$session_name]}" ]; then
				attached_session_name="$session_name"
				break
			fi
		done
	fi

	# Now find the display string for this attached session
	if [ -n "$attached_session_name" ]; then
		# Check regular sessions (simple string match)
		for ((j=0; j<${#regular_sessions[@]}; j++)); do
			if [[ "${regular_sessions[$j]}" == *"$attached_session_name"* ]]; then
				attached_display="${regular_sessions[$j]}"
				break
			fi
		done

		# If not found in regular, check saved sessions (simple string match)
		if [ -z "$attached_display" ]; then
			for session in "${saved_sessions[@]}"; do
				if [[ "$session" == *"$attached_session_name"* ]]; then
					attached_display="$session"
					break
				fi
			done
		fi
	fi

	# Output attached session first (if found)
	if [ -n "$attached_display" ]; then
		echo -e "$attached_display"
	fi

	# Output regular sessions (sorted by newest, excluding attached)
	for ((j=0; j<${#regular_sessions[@]}; j++)); do
		if [[ "${regular_sessions[$j]}" != *"$attached_session_name"* ]]; then
			echo -e "${regular_timestamps[$j]} ${regular_sessions[$j]}"
		fi
	done | sort -rn | cut -d' ' -f2-

	# Output saved sessions (in TOML order, excluding attached)
	for session in "${saved_sessions[@]}"; do
		if [[ "$session" != *"$attached_session_name"* ]]; then
			echo -e "$session"
		fi
	done
}

get_session_name() {
	# Strip ANSI codes and extract session name (faster than sed)
	local clean=${1//\\x1b\[[0-9;]*m/}
	clean=${clean#★ }
	echo "${clean%% ·*}"
}

detach_session() {
	local session_name=$(get_session_name "$1")
	if gum confirm "Detach session '$session_name'?"; then
		tmux detach-client -s "$session_name" 2>/dev/null
	fi
}

generate_random_name() {
	local data_dir=$(get_data_dir)
	local adjective=$(shuf -n1 "${data_dir}/adjectives.txt")
	local noun=$(shuf -n1 "${data_dir}/nouns.txt")
	echo "${adjective}-${noun}"
}

create_session() {
	local suggested_name=$(generate_random_name)
	local new_name=$(gum input --placeholder "Session name" --value "$suggested_name")
	if [ -n "$new_name" ]; then
		tmux new-session -d -s "$new_name"
		switch_to_session "$new_name"
	fi
}

rename_session() {
	local session_name=$(get_session_name "$1")
	local new_name=$(gum input --placeholder "New name" --value "$session_name")
	if [ -n "$new_name" ]; then
		tmux rename-session -t "$session_name" "$new_name"
	fi
}

kill_session() {
	local session_name=$(get_session_name "$1")
	if gum confirm "Kill session '$session_name'?"; then
		tmux kill-session -t "$session_name" 2>/dev/null
	fi
}

switch_to_session() {
	local session_name="$1"
	
	# If session doesn't exist, check if it's a saved session and create it
	if ! session_exists "$session_name"; then
		if is_saved_session "$session_name"; then
			local config=$(get_saved_session_config "$session_name")
			local path=$(echo "$config" | cut -f1)
			local startup_cmd=$(echo "$config" | cut -f2)
			
			# Expand ~ in path
			path="${path/#\~/$HOME}"
			
			# Create the session with the specified path
			tmux new-session -d -s "$session_name" -c "$path"
			
			# Run startup command if specified
			if [ -n "$startup_cmd" ]; then
				tmux send-keys -t "$session_name" "$startup_cmd" Enter
			fi
		else
			# Not a saved session and doesn't exist - can't switch
			return 1
		fi
	fi
	
	# Switch or attach to the session
	if [ -n "$TMUX" ]; then
		tmux switch-client -t "$session_name"
	else
		tmux attach -t "$session_name"
	fi
}

main() {
	formatted_sessions=$(get_formatted_sessions)
	
	selection=$(echo "$formatted_sessions" | fzf \
		--ansi \
		--header "[enter: switch, C-n: new, C-r: rename, C-d: detach, C-x: kill]" \
		--bind "ctrl-d:execute($SCRIPT_PATH --detach {})+reload($SCRIPT_PATH --list)" \
		--bind "ctrl-n:execute($SCRIPT_PATH --new)+reload($SCRIPT_PATH --list)" \
		--bind "ctrl-r:execute($SCRIPT_PATH --rename {})+reload($SCRIPT_PATH --list)" \
		--bind "ctrl-x:execute($SCRIPT_PATH --kill {})+reload($SCRIPT_PATH --list)" \
		--bind "enter:accept" \
		--bind "tab:down" \
		--bind "shift-tab:up" \
		--cycle \
		--reverse \
	)
	
	if [ -n "$selection" ]; then
		session_name=$(get_session_name "$selection")
		switch_to_session "$session_name"
	fi
}

# Handle command line arguments for fzf callbacks
case "$1" in
	--detach)
		shift
		detach_session "$*"
		;;
	--new)
		create_session
		;;
	--rename)
		shift
		rename_session "$*"
		;;
	--kill)
		shift
		kill_session "$*"
		;;
	--list)
		get_formatted_sessions
		;;
	*)
		main
		;;
esac
